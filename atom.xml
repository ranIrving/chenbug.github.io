<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chenran</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-17T01:02:42.599Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RONY CHEN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/17/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(8)%EF%BC%9A%E6%97%A0%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/17/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(8)%EF%BC%9A%E6%97%A0%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-03-17T01:02:42.479Z</published>
    <updated>2020-03-17T01:02:42.599Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/15/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/15/%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-03-15T14:50:20.173Z</published>
    <updated>2020-03-15T15:49:45.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运行意味着有大于或等于进程数量的线程在运行。</p><p>对于多进程来说，每个进程都有属于自己的 GIL，所以，在多核处理器下，多进程的运行是不会受 GIL 的影响的。因此，多进程能更好地发挥多核的优势。</p><p>对于计算密集型任务来说，Python 的多进程相比多线程，其多核运行效率会有成倍的提升。</p><h1 id="多进程的实现"><a href="#多进程的实现" class="headerlink" title="多进程的实现"></a>多进程的实现</h1><p>如python提供的multiprocessing库，其提供了一系列的组件，如 Process（进程）、Queue（队列）、Semaphore（信号量）、Pipe（管道）、Lock（锁）、Pool（进程池）等</p><p>在multiprocessing中，每一个进程都用一个Process类来表示。它的API调用如下：Process</p><pre><code>([group[,target[,name[,args[,   kwargs]]]]])</code></pre><p>1、target表示调用对象，你可以传入方法的名字。</p><p>2、args表示被调用对象的位置参数元组，比如target是函数func，他有两个参数m，n，那么args就传入[m,n]即可。</p><p>3、kwargs 表示调用对象的字典。</p><p>4、name 是别名，相当于给这个进程取一个名字。</p><p>5、group 分组。</p><p>实例代码如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多进程&quot;&gt;&lt;a href=&quot;#多进程&quot; class=&quot;headerlink&quot; title=&quot;多进程&quot;&gt;&lt;/a&gt;多进程&lt;/h1&gt;&lt;p&gt;多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运行意味着有大于或等于进程数量的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(5)%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(5)%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-15T08:39:38.575Z</published>
    <updated>2020-03-15T09:32:02.132Z</updated>
    
    <content type="html"><![CDATA[<p>前言：为了提高爬取效率，我们会使用多进程和多线程的知识。</p><h1 id="多线程的含义"><a href="#多线程的含义" class="headerlink" title="多线程的含义"></a>多线程的含义</h1><p>首先我们先理解什么是进程？进程我们可以理解为是一个可以独立运行的程序单位。而一个进程有人能包含很多任务，就像浏览网页是一个进程，但同时可以听音乐、刷视频、播放动画，并且之前可以同时运行，互不干扰。</p><p>而这就是一个个线程的执行。进程是线程的集合，进程是有一个或者多个线程构成的。线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。</p><p>如此，多线程就是指一个进程中同时执行多个进程。</p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>我们需要知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p><p>并发(concurrency):它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。</p><p>并行，(parallel):它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p><p>并行只能在多处理器系统中存在,而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p><p>多线程适用场景有哪些？</p><p>一些操作是比较耗时或者需要等待的，即线程执行过程中很多情况下需要等待。</p><p>比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于 IO 密集型任务。</p><p>但并不是所有的任务都是 IO 密集型任务，还有一种任务叫作计算密集型任务，也可以称之为 CPU 密集型任务。简而言之，当时用多线程时，如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p><p>那么如何在python中使用多线程呢？</p><p>python中，实现多线程的模块为threading，是python自带模块。使用方法如下：</p><p>（代码）</p><h1 id="python多线程的问题"><a href="#python多线程的问题" class="headerlink" title="python多线程的问题"></a>python多线程的问题</h1><p>由于 Python 中 GIL 的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致 Python 多线程无法发挥多核并行的优势。</p><p>GIL(Global Interpreter Lock)，译为全局解释器锁，其最初设计是出于数据安全而考虑的。</p><p>在 Python 多线程下，每个线程的执行方式如下：</p><p>1、获取 GIL</p><p>2、执行对应线程的代码</p><p>3、释放 GIL</p><p>可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是通行证，并且在一个Python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。</p><p>这样就会导致，即使是多核条件下，一个Python进程下的多个线程，同一时刻也只能执行一个线程。不过对于爬虫这种IO密集型任务来说，这个问题影响并不大。</p><p>而对于计算密集型任务来说，由于GIL的存在，多线程总体的运行效率相比可能反而比单线程更低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：为了提高爬取效率，我们会使用多进程和多线程的知识。&lt;/p&gt;
&lt;h1 id=&quot;多线程的含义&quot;&gt;&lt;a href=&quot;#多线程的含义&quot; class=&quot;headerlink&quot; title=&quot;多线程的含义&quot;&gt;&lt;/a&gt;多线程的含义&lt;/h1&gt;&lt;p&gt;首先我们先理解什么是进程？进程我们可
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(4)%EF%BC%9ASession%E5%92%8CCookies%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(4)%EF%BC%9ASession%E5%92%8CCookies%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-03-15T07:42:59.312Z</published>
    <updated>2020-03-15T08:27:28.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h1><p>静态网页：网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据URL灵活多变地显示内容等。</p><p>动态网页：它可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。并且动态网站还可以实现用户登录和注册的功能。</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。</p><p>简单来说：服务器独立完成解析请求后，不会记录前后的状态变化，即缺少状态记录。</p><p>因此，Session和Cookies两种用于保持HTTP连接状态的技术就出现了。</p><p>Session 在服务端，也就是网站的服务器，用来保存用户的 Session 信息；</p><p>Cookies 在客户端，也可以理解为浏览器端。可理解为，只需要在下次请求携带 Cookies 发送请求而不必重新输入用户名、密码等信息重新登录了。</p><h2 id="那么到底什么是Session和Cookies呢？"><a href="#那么到底什么是Session和Cookies呢？" class="headerlink" title="那么到底什么是Session和Cookies呢？"></a>那么到底什么是Session和Cookies呢？</h2><p>Session：意为会话，本身的含义是指有始有终的一系列动作 / 消息。</p><p>在web中，Session 对象用来存储特定用户 Session 所需的属性及配置信息。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session 对象。当 Session 过期或被放弃后，服务器将终止该 Session。</p><p>Cookies： 指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据。</p><h3 id="Session维持-如何利用Session保持状态呢？"><a href="#Session维持-如何利用Session保持状态呢？" class="headerlink" title="Session维持 如何利用Session保持状态呢？"></a>Session维持 如何利用Session保持状态呢？</h3><p>当c(客户端)第一次请求s(服务器)时，s会返回一个响应头中带有 Set-Cookie 字段的响应给客c，用来标记是哪一个用户，c浏览器会把 Cookies 保存起来。</p><p>当浏器览下一次再请求该网站时，浏览器会把此Cookies放到请求头一起提交给s，Cookies携带了SessionID信息，s检查该Cookies即可找到对应的Session是什么，然后再判断Session来一次来辨认用户状态。</p><p>在成功登录某个网站时，s会告诉c设置哪些 Cookies 信息，在后续访问页面时c会把 Cookies 发送给s，s再找到对应的 Session 加以判断。</p><p>如果 Session 中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p><p>反之，如果传给s的 Cookies 是无效的，或者 Session 已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。</p><p>所以，Cookies 和 Session 需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session 控制。</p><h2 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h2><p>以知乎为例，看看Cookies都有哪些内容，在浏览器开发者工具中打开 Application 选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies：</p><p>（表|图）</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、一般只有程序通知服务器删除一个 Session，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除 Session。</p><p>2、服务器不会知道浏览器关闭。因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session 了。</p><p>如果服务器设置的Cookies保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器，仍然能够找到原来的SessionID，依旧还是可以保持登陆状态的。</p><p>3、由于关闭浏览器不会导致Session被删除，这就需要服务器为Session设置一个失效时间，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活，才会把 Session 删除以节省存储空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态网页和动态网页&quot;&gt;&lt;a href=&quot;#静态网页和动态网页&quot; class=&quot;headerlink&quot; title=&quot;静态网页和动态网页&quot;&gt;&lt;/a&gt;静态网页和动态网页&lt;/h1&gt;&lt;p&gt;静态网页：网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(3)%EF%BC%9A%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(3)%EF%BC%9A%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-15T03:54:19.285Z</published>
    <updated>2020-03-15T07:42:13.054Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫概述：爬虫就是获取网页并提取和保存信息的自动化程序</p><p>网页获取：即获取网页源代码，然后从源代码中提取想要的信息。并且python提供许多库，如urllib、request，让我们能够简单的获取网页，并且解析数据内容。</p><p>提取信息：最常用方法是正则表达式。</p><p>由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如BeautifulSoup、pyquery、lxml等。使用这些库，我们可以高效快速提取网页信息，如节点的属性、文本值等。</p><p>保存数据：信息提取出来后，需要保存以便后续使用。简单的可保存为TXT文本或JSON文本，或者<br>保存至数据库。如MySQL 和 MongoDB 等，还可保存至远程服务器，如借助 SFTP 进行操作等。</p><p>自动化程序：让爬虫代替人去自动爬取数据。并且在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><p>数据类型不同如何抓取？</p><p>1、有些网页返回的不是 HTML 代码，而是一个 JSON 字符串（其中 API 接口大多采用这样的形、式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p><p>2、各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p><p>3、各种扩展名的文件，如 CSS、JavaScript 和配置文件</p><p>4、JavaScript 渲染页面</p><p>我们在用 urllib 或 requests 抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p><p>现在网页越来越多地采用 Ajax、前端模块化工具来构建，整个网页可能都是由 JavaScript 渲染出来的，也就是说原始的 HTML 代码就是一个空壳，例如：</p><p>（图）</p><p>body 节点里面只有一个 id 为 container 的节点，但是需要注意在 body 节点后引入了 app.js，它便负责整个网站的渲染。</p><p>（图）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬虫概述：爬虫就是获取网页并提取和保存信息的自动化程序&lt;/p&gt;
&lt;p&gt;网页获取：即获取网页源代码，然后从源代码中提取想要的信息。并且python提供许多库，如urllib、request，让我们能够简单的获取网页，并且解析数据内容。&lt;/p&gt;
&lt;p&gt;提取信息：最常用方法是正则
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(2)%EF%BC%9Aweb%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/15/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(2)%EF%BC%9Aweb%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-15T03:06:24.547Z</published>
    <updated>2020-03-15T03:53:47.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web网页基础"><a href="#web网页基础" class="headerlink" title="web网页基础"></a>web网页基础</h1><p>网页组成：HTML、CSS、javaScript。</p><p>HTML：超文本标记语言。浏览的网页的元素其基础架构就是HTML。而不同类型的元素通过不同类型的标签来表示。</p><p>如图片用 img 标签表示，视频用 video 标签表示，段落用 p 标签表示，它们之间的布局又常通过布局标签 div 嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。</p><p>CSS：层叠样式表。浏览器能够将HTML引发的样式冲突进行顺序处理；是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p><p>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中（其后缀为 css）。在 HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。</p><p>JavaScript：简称js，一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。而我们看到的下载进度条、提示框、轮播图等，通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。</p><p>JavaScript通常也是以单独的文件形式加载的，后缀为js，在HTML中通过script标签即可引入，例如：</p><pre><code>&amp;lt;script src=&quot;jquery-2.1.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;</code></pre><p>一个网页的标准形式是 html 标签内嵌套 head 和 body 标签，head 内定义网页的配置和引用，body 内定义网页的正文。</p><p>节点树及节点间的关系</p><p>在HTML中，所有标签定义的内容都是节点，它们构成了一个HTML DOM树。而DOM是W3C（万维网联盟）的标准。</p><p>W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p><p>W3C DOM 标准被分为 3 个不同的部分：<br>核心 DOM - 针对任何结构化文档的标准模型<br>XML DOM - 针对 XML 文档的标准模型<br>HTML DOM - 针对 HTML 文档的标准模型</p><p>根据W3C的HTMLDOM标准，HTML文档中的所有内容都是节点：</p><p>1、整个文档是一个文档节点</p><p>2、每个HTML元素是元素节点</p><p>3、HTML元素内的文本是文本节点</p><p>4、每个HTML属性是属性节点 </p><p>5、注释是注释节点。</p><p>通过HTML DOM，树中的所有节点均可通过JavaScript访问，所有HTML节点元素均可被修改，也可以被创建或删除。</p><p>节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。</p><p>在节点树中，顶端节点称为根（root）。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。</p><p>选择器</p><p>网页由一个个节点组成，CSS 选择器会根据不同的节点设置不同的样式规则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web网页基础&quot;&gt;&lt;a href=&quot;#web网页基础&quot; class=&quot;headerlink&quot; title=&quot;web网页基础&quot;&gt;&lt;/a&gt;web网页基础&lt;/h1&gt;&lt;p&gt;网页组成：HTML、CSS、javaScript。&lt;/p&gt;
&lt;p&gt;HTML：超文本标记语言。浏览的网
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/14/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(1)%EF%BC%9AHTTP%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/14/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0(1)%EF%BC%9AHTTP%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-14T03:52:30.049Z</published>
    <updated>2020-03-14T04:12:58.029Z</updated>
    
    <content type="html"><![CDATA[<p>URI：包括URL和URN。</p><p>一般网页的链接称之为URL。</p><p>超文本：网页的源代码HTML称之为超文本。</p><p>HTTP和HTTPS</p><p>URL 的开头会有 http 或 https，这个就是访问资源需要的协议类型，有时我们还会看到 ftp、sftp、smb 开头的 URL，那么这里的 ftp、sftp、smb 都是指的协议类型。</p><p>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的。</p><p>HTTP请求过程：</p><p>浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</p><p>请求：请求方法（Request Method）、请求的网址（Request URL）、请求头（Request Headers）、请求体（Request Body）</p><p>请求方法：GET 和 POST。</p><p>两种方法区别：</p><p>1、GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</p><p>2、GET请求提交的数据最多只有1024个字节，而 POST 请求没有限制。</p><p>一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用GET方式请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以POST方式发送。</p><p>上传文件时，由于文件内容比较大，也会选用 POST 方式。</p><p>请求头：用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。</p><p>请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。<br>请求体</p><p>（）</p><p>请求体：一般承载的内容是 POST 请求中的表单数据，而对于 GET 请求，请求体则为空。</p><p>响应：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p><p>响应头包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。下面简要说明一些常用的头信息。</p><p>（）</p><p>响应体</p><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的 HTML 代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，</p><p>浏览器开发者工具中点击 Preview，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p><p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON 数据等，然后从中做相应内容的提取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;URI：包括URL和URN。&lt;/p&gt;
&lt;p&gt;一般网页的链接称之为URL。&lt;/p&gt;
&lt;p&gt;超文本：网页的源代码HTML称之为超文本。&lt;/p&gt;
&lt;p&gt;HTTP和HTTPS&lt;/p&gt;
&lt;p&gt;URL 的开头会有 http 或 https，这个就是访问资源需要的协议类型，有时我们还会看
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/29/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/29/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-29T08:02:58.138Z</published>
    <updated>2020-02-29T09:21:16.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-字符串操作"><a href="#第六章-字符串操作" class="headerlink" title="第六章 字符串操作"></a>第六章 字符串操作</h1><h2 id="6-1-处理字符串"><a href="#6-1-处理字符串" class="headerlink" title="6.1 处理字符串"></a>6.1 处理字符串</h2><h3 id="6-1-1"><a href="#6-1-1" class="headerlink" title="6.1.1"></a>6.1.1</h3><p>字符串可以用双引号开始和结束，就像用单引号一样。使用双引号的一个好处，就是字符串中可以使用单引号字符。</p><p>转义字符包含一个倒斜杠（\），紧跟着是想要添加到字符串中的字符。单引号的转义字符是&#39;</p><p>(图)</p><p>在字符串开始的引号之前加上r，使它成为原始字符串。“原始字符串”完全忽略所有的转义字符，打印出字符串中所有的倒斜杠。</p><p>在Python中，多行字符串的起止是3个单引号或3个双引号。“三重引号”之间的所有引号、制表符或换行，都被认为是字符串的一部分。</p><h3 id="6-1-2-字符串下标和切片"><a href="#6-1-2-字符串下标和切片" class="headerlink" title="6.1.2 字符串下标和切片"></a>6.1.2 字符串下标和切片</h3><p>字符串像列表一样，使用下标和切片。且字符计数包含了空格和感叹号。</p><p>如果用一个下标和另一个下标指定一个范围，开始下标将被包含，结束下标则不包含。</p><pre><code>spam = &apos;Say hi to Bob&apos;print(spam[0:5])Say h</code></pre><h3 id="6-1-3-字符串的in和not-in操作符"><a href="#6-1-3-字符串的in和not-in操作符" class="headerlink" title="6.1.3 字符串的in和not in操作符"></a>6.1.3 字符串的in和not in操作符</h3><p>in和not in操作符也可以用于字符串。用in或not in连接两个字符串得到的表达式，将求值为布尔值True或False。</p><pre><code>print(&apos;hello&apos; in &apos;hello world&apos;)print(&apos;hello&apos; not in &apos;hello world&apos;)TrueFalse</code></pre><h2 id="6-2-字符串方法"><a href="#6-2-字符串方法" class="headerlink" title="6.2 字符串方法"></a>6.2 字符串方法</h2><h3 id="6-2-1-字符串方法upper-、lower-、isupper-和islower"><a href="#6-2-1-字符串方法upper-、lower-、isupper-和islower" class="headerlink" title="6.2.1 字符串方法upper()、lower()、isupper()和islower()"></a>6.2.1 字符串方法upper()、lower()、isupper()和islower()</h3><p>upper()和lower()字符串方法返回一个新字符串，其中  原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变。upper()和lower()字符串方法本身返回字符串。</p><pre><code>spam = &apos;Hello World!&apos;print(spam.upper())print(spam.lower())HELLO WORLD!hello world!</code></pre><p>如果字符串至少有一个字母，并且所有字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True。否则，该方法返回False。</p><pre><code>spam = &apos;Hello World!&apos;print(spam.islower())print(spam.isupper())FalseFalse</code></pre><h3 id="6-2-2-其他isX字符串方法"><a href="#6-2-2-其他isX字符串方法" class="headerlink" title="6.2.2 其他isX字符串方法"></a>6.2.2 其他isX字符串方法</h3><p>isalpha()返回True，如果字符串只包含字母，并且非空 ；</p><p>isalnum()返回True，如果字符串只包含字母和数字，并且非空；</p><p>isdecimal()返回True，如果字符串只包含数字字符，并且非空；</p><p>isspace()返回True，如果字符串只包含空格、制表符和换行，并且非空；</p><p>istitle()返回True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。</p><h3 id="6-2-3-字符串方法startswith-和endswith"><a href="#6-2-3-字符串方法startswith-和endswith" class="headerlink" title="6.2.3 字符串方法startswith()和endswith()"></a>6.2.3 字符串方法startswith()和endswith()</h3><p>startswith()和endswith()方法返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束。否则，方法返回False。</p><pre><code>print(&apos;Hello World!&apos;.startswith(&apos;Hello&apos;))print(&apos;Hello World!&apos;.startswith(&apos;world&apos;))TrueFalse</code></pre><h3 id="6-2-4-字符串方法join-和split"><a href="#6-2-4-字符串方法join-和split" class="headerlink" title="6.2.4 字符串方法join()和split()"></a>6.2.4 字符串方法join()和split()</h3><p>join()方法,可将一个字符串列表连接起来，成为一个单独的字符串。</p><pre><code>print(&apos;, &apos;.join([&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]))cat, dog, pig</code></pre><p>join()方法是针对一个字符串而调用的，并且传入一个列表值（很容易不小心用其他的方式调用它）。split()方法做的事情正好相反：它针对一个字符串调用，返回一个字符串列表。</p><pre><code>print(&apos;My name is chenbug&apos;.split())#split()括号里可以指定分隔字符print(&apos;My name is chenbug&apos;.split(&apos;e&apos;))[&apos;My&apos;, &apos;name&apos;, &apos;is&apos;, &apos;chenbug&apos;][&apos;My nam&apos;, &apos; is ch&apos;, &apos;nbug&apos;]</code></pre><h3 id="6-2-5-用rjust-、ljust-和center-方法对齐文本"><a href="#6-2-5-用rjust-、ljust-和center-方法对齐文本" class="headerlink" title="6.2.5 用rjust()、ljust()和center()方法对齐文本"></a>6.2.5 用rjust()、ljust()和center()方法对齐文本</h3><p>rjust()和ljust()字符串方法返回调用它们的字符串的填充版本，通过插入空格来对齐文本。这两个方法的第一个参数是一个整数长度，用于对齐字符串。</p><pre><code>print(&apos;Hello&apos;.rjust(10))print(&apos;Hello&apos;.ljust(10))print(&apos;Hello&apos;.ljust(10,&apos;*&apos;))     HelloHello     #Hello*****</code></pre><p>center()字符串方法,它是让文本居中。</p><pre><code>print(&apos;Hello&apos;.center(10,&apos;*&apos;))**Hello***</code></pre><h3 id="6-2-6-用strip-、rstrip-和lstrip-删除空白字符"><a href="#6-2-6-用strip-、rstrip-和lstrip-删除空白字符" class="headerlink" title="6.2.6 用strip()、rstrip()和lstrip()删除空白字符"></a>6.2.6 用strip()、rstrip()和lstrip()删除空白字符</h3><p>strip()字符串方法将返回一个新的字符串，它的开头或末尾都没有空白字符。lstrip()和rstrip()方法将相应删除左边或右边的空白。</p><p>有一个可选的字符串参数，指定两边的哪些字符应该删除。向strip()方法传入参数’henC’，告诉它在变量中存储的字符串两端，删除出现的h、e、n和大写的C。且字符顺序不重要。</p><pre><code>spam = &apos;ChenChenBugRanBugChenChen&apos;print(spam.strip(&apos;henC&apos;))BugRanBug</code></pre><h3 id="6-2-7-用pyperclip模块拷贝粘贴字符串"><a href="#6-2-7-用pyperclip模块拷贝粘贴字符串" class="headerlink" title="6.2.7 用pyperclip模块拷贝粘贴字符串"></a>6.2.7 用pyperclip模块拷贝粘贴字符串</h3><p>import pyperclip<br>pyperclip.copy(‘Chenbug is a handsome boy!’)<br>print(pyperclip.paste())</p><p>Chenbug is a handsome boy!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第六章-字符串操作&quot;&gt;&lt;a href=&quot;#第六章-字符串操作&quot; class=&quot;headerlink&quot; title=&quot;第六章 字符串操作&quot;&gt;&lt;/a&gt;第六章 字符串操作&lt;/h1&gt;&lt;h2 id=&quot;6-1-处理字符串&quot;&gt;&lt;a href=&quot;#6-1-处理字符串&quot; class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/28/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/28/%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-28T12:22:07.329Z</published>
    <updated>2020-02-28T13:03:46.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典和结构化数据"><a href="#字典和结构化数据" class="headerlink" title="字典和结构化数据"></a>字典和结构化数据</h1><h2 id="5-1字典数据类型"><a href="#5-1字典数据类型" class="headerlink" title="5.1字典数据类型"></a>5.1字典数据类型</h2><p>字典的索引被称为“键”，键及其关联的值称为“键-值”对。</p><pre><code>myCat = {&apos;size&apos;: &apos;fat&apos;, &apos;color&apos;: &apos;gray&apos;, &apos;disposition&apos;: &apos;loud&apos;}print(myCat[&apos;size&apos;])fat</code></pre><p>字典仍然可以用整数值作为键:</p><pre><code>spam = {12345: &apos;Luggage Combination&apos;, 42: &apos;The Answer&apos;} </code></pre><h3 id="5-1-1-字典与列表"><a href="#5-1-1-字典与列表" class="headerlink" title="5.1.1 字典与列表"></a>5.1.1 字典与列表</h3><p>字典是不排序的，所以不能像列表那样切片</p><pre><code>eggs = {&apos;name&apos;: &apos;Zophie&apos;, &apos;species&apos;: &apos;cat&apos;, &apos;age&apos;: &apos;8&apos;}ham = {&apos;species&apos;: &apos;cat&apos;, &apos;age&apos;: &apos;8&apos;, &apos;name&apos;: &apos;Zophie&apos;}eggs = hamTrue</code></pre><p>虽然字典是不排序的，但可以用任意值作为键。</p><h3 id="5-1-2-keys-、values-和-items-方法"><a href="#5-1-2-keys-、values-和-items-方法" class="headerlink" title="5.1.2 keys()、values()和 items()方法"></a>5.1.2 keys()、values()和 items()方法</h3><p>对应于字典的键、值和键-值对：keys()、values()和items()</p><p>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。</p><p>但这些数据类型（分别是dict_keys、dict_values和dict_items）可以用于for循环。</p><pre><code>spam = {&apos;color&apos;: &apos;red&apos;, &apos;age&apos;: 42}for v in spam.values():    print(v)red42for k in spam.keys():    print(k)coloragefor i in spam.items():    print(i)(&apos;color&apos;, &apos;red&apos;)(&apos;age&apos;, 42)</code></pre><p>如何得到真正的列表：<br>    spam = {‘color’: ‘red’, ‘age’: 42}<br>    spam.keys()<br>    print(list(spam.keys()))</p><pre><code>[&apos;color&apos;, &apos;age&apos;]</code></pre><p>list(spam.keys())代码行接受keys()函数返回的dict_keys值，并传递给list()。然后返回一个列表，即[‘color’, ‘age’]。</p><h3 id="5-1-3-检查字典中是否存在键或值"><a href="#5-1-3-检查字典中是否存在键或值" class="headerlink" title="5.1.3 检查字典中是否存在键或值"></a>5.1.3 检查字典中是否存在键或值</h3><p>使用in和not in 操作符</p><pre><code>spam = {&apos;name&apos;: &apos;Zophie&apos;, &apos;age&apos;: 7}print(&apos;name&apos; in spam.keys()) True</code></pre><h3 id="5-1-4-get-方法"><a href="#5-1-4-get-方法" class="headerlink" title="5.1.4 get()方法"></a>5.1.4 get()方法</h3><p>字典有一个get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。</p><pre><code>picnicItems = {&apos;apples&apos;: 5, &apos;cups&apos;: 2}print(&apos;I am bringing &apos; + str(picnicItems.get(&apos;cups&apos;, 0)) + &apos; cups.&apos;)I am bringing 2 cups. </code></pre><h3 id="5-1-5-setdefault-方法"><a href="#5-1-5-setdefault-方法" class="headerlink" title="5.1.5 setdefault()方法"></a>5.1.5 setdefault()方法</h3><p>我们需要为字典中某个键设置一个默认值，当该键没有任何值时使用它。</p><p>setdefault()方法提供了一种方式，在一行中完成这件事。传递给该方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。如果该键确实存在，方法就会返回键的值。</p><pre><code>spam = {&apos;name&apos;: &apos;Pooka&apos;, &apos;age&apos;: 5}print(spam.setdefault(&apos;color&apos;, &apos;black&apos;))print(spam)print( spam.setdefault(&apos;color&apos;, &apos;white&apos;))print(spam)</code></pre><p>  （图）</p><p>第一次调用setdefault()时，spam变量中的字典变为{‘color’: ‘black’, ‘age’: 5, ‘name’: ‘Pooka’}。该方法返回值’black’，因为现在该值被赋给键’color’。当spam.setdefault(‘color’, ‘white’)接下来被调用时，该键的值“没有”被改变成’white’，因为spam变量已经有名为’color’的键。</p><pre><code>message = &apos;It was a bright cold day in April, and the clocks were striking thirteen.&apos;count = {}for character in message:    count.setdefault(character, 0)    count[character] = count[character] + 1print(count)</code></pre><p>（图）</p><h2 id="5-2-漂亮打印"><a href="#5-2-漂亮打印" class="headerlink" title="5.2 漂亮打印"></a>5.2 漂亮打印</h2><p>导入pprint模块，就可以使用pprint()和pformat()函数，它们将“漂亮打印”一个字典的字。如果想要字典中表项的显示比print()的输出结果更干净，这就有用了。</p><pre><code>import pprintmessage = &apos;It was a bright cold day in April, and the clocks were strikingthirteen.&apos;count = {}for character in message:    count.setdefault(character, 0)    count[character] = count[character] + 1pprint.pprint(count)希望得到漂亮打印的文本作为字符串，而不是显示在屏幕上，那就调用pprint.pformat()。pprint.pprint(someDictionaryValue)print(pprint.pformat(someDictionaryValue)</code></pre><h2 id="5-3-嵌套的字典和列表"><a href="#5-3-嵌套的字典和列表" class="headerlink" title="5.3 嵌套的字典和列表"></a>5.3 嵌套的字典和列表</h2><pre><code>allGuests = {&apos;Alice&apos;: {&apos;apples&apos;: 5, &apos;pretzels&apos;: 12},             &apos;Bob&apos;: {&apos;ham sandwiches&apos;: 3, &apos;apples&apos;: 2},             &apos;Carol&apos;: {&apos;cups&apos;: 3, &apos;apple pies&apos;: 1}}def totalBrought(guests, item):     numBrought = 0    for k, v in guests.items():        numBrought = numBrought + v.get(item, 0)    return numBroughtprint(&apos;Number of things being brought:&apos;)print(&apos; - Apples &apos; + str(totalBrought(allGuests, &apos;apples&apos;)))print(&apos; -  Cups &apos; + str(totalBrought(allGuests, &apos;cups&apos;)))print(&apos; -  Cakes &apos; + str(totalBrought(allGuests, &apos;cakes&apos;)))print(&apos; -  Ham Sandwiches &apos; + str(totalBrought(allGuests, &apos;ham sandwiches&apos;)))print(&apos; -  Apple Pies &apos; + str(totalBrought(allGuests, &apos;apple pies&apos;)))</code></pre><p>（图）</p><p>在totalBrought()函数中，for循环迭代guests中的每个键值对。在这个循环里，客人的名字字符串赋给k，他们带来的野餐食物的字典赋给v。如果食物参数是字典中存在的键，它的值  （数量） 就添加到numBrought。如果它不是键，get()方法就返回0， 添加到numBrought。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字典和结构化数据&quot;&gt;&lt;a href=&quot;#字典和结构化数据&quot; class=&quot;headerlink&quot; title=&quot;字典和结构化数据&quot;&gt;&lt;/a&gt;字典和结构化数据&lt;/h1&gt;&lt;h2 id=&quot;5-1字典数据类型&quot;&gt;&lt;a href=&quot;#5-1字典数据类型&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/28/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-28T05:46:20.990Z</published>
    <updated>2020-02-28T06:39:25.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="4-1-列表数据类型"><a href="#4-1-列表数据类型" class="headerlink" title="4.1 列表数据类型"></a>4.1 列表数据类型</h2><p>“列表”是一个值，它包含多个字构成的序列。</p><p>列表中第一个值的下标是0，第二个值的下标是1，第三个值的下标是2，依此类推。</p><p>列表也可以包含其他列表值。这些列表的列表中的值，可以通过多重下标来访问：</p><pre><code>spam = [[&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;],[&apos;10&apos;,&apos;12&apos;,&apos;15&apos;]]spam[0][&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]</code></pre><p>整数值−1指的是列表中的最后一个下标，−2指的是列表中倒数第二个下标，以此类推。</p><p>“ 切片”可以从列表中取得多个值，结果是一个新列表。切片输入在一对方括号中，像下标一样，但它有两个冒号分隔的整数。</p><pre><code>spam[1:4]是一个列表和切片spam = [&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]spam[0:3][&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]spam[1:3][&apos;dog&apos;,&apos;pig&apos;]</code></pre><p>可以省略切片中冒号两边的一个下标或两个下标。省略第一个下标相当于使用0，或列表的开始。省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾。</p><h3 id="4-1-1-用len-取得列表的长度"><a href="#4-1-1-用len-取得列表的长度" class="headerlink" title="4.1.1 用len()取得列表的长度"></a>4.1.1 用len()取得列表的长度</h3><pre><code>spam = [&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]len(spam)3</code></pre><h3 id="4-1-2-用下标改变列表中的值"><a href="#4-1-2-用下标改变列表中的值" class="headerlink" title="4.1.2 用下标改变列表中的值"></a>4.1.2 用下标改变列表中的值</h3><pre><code>spam = [&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]spam[1] = &apos;mouse&apos;spam[&apos;cat&apos;,&apos;mouse&apos;,&apos;pig&apos;]</code></pre><h3 id="4-1-3-列表连接和列表复制"><a href="#4-1-3-列表连接和列表复制" class="headerlink" title="4.1.3 列表连接和列表复制"></a>4.1.3 列表连接和列表复制</h3><p>‘+’操作符可以连接两个列表，得到一个新列表；’*’操作符可以用于一个列表和一个整数，实现列表的复制。</p><h3 id="4-1-4-用del语句从列表中删除值"><a href="#4-1-4-用del语句从列表中删除值" class="headerlink" title="4.1.4 用del语句从列表中删除值"></a>4.1.4 用del语句从列表中删除值</h3><p>del语句将删除列表中下标处的值，表中被删除值后面的所有值，都将向前移动一个下标。</p><pre><code>spam = [&apos;cat&apos;,&apos;dog&apos;,&apos;pig&apos;]del spam[2]spam[&apos;cat&apos;,&apos;dog&apos;]</code></pre><h2 id="4-2-使用列表"><a href="#4-2-使用列表" class="headerlink" title="4.2 使用列表"></a>4.2 使用列表</h2><h3 id="4-2-1-列表用于循环"><a href="#4-2-1-列表用于循环" class="headerlink" title="4.2.1 列表用于循环"></a>4.2.1 列表用于循环</h3><pre><code>    supplies = [&apos;pens&apos;, &apos;staplers&apos;, &apos;flame-throwers&apos;, &apos;binders&apos;]     for i in range(len(supplies)): #range(len(supplies))将迭代supplies的所有下标，无论它包含多少表项。    print(&apos;Index &apos; + str(i) + &apos; in supplies is: &apos; + supplies[i])Index 0 in supplies is: pensIndex 1 in supplies is: staplersIndex 2 in supplies is: flame-throwersIndex 3 in supplies is: binders </code></pre><h3 id="4-2-2-in和not-in-操作符"><a href="#4-2-2-in和not-in-操作符" class="headerlink" title="4.2.2 in和not in 操作符"></a>4.2.2 in和not in 操作符</h3><p>利用in和not in操作符，   可以确定一个值否在列表中。</p><h3 id="4-2-3-多重赋值技巧和操作"><a href="#4-2-3-多重赋值技巧和操作" class="headerlink" title="4.2.3 多重赋值技巧和操作"></a>4.2.3 多重赋值技巧和操作</h3><p>变量的数目和列表的长度必须严格相等，否则Python将给出ValueError</p><h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h2><h3 id="4-3-1-用index-方法在列表中查找值"><a href="#4-3-1-用index-方法在列表中查找值" class="headerlink" title="4.3.1 用index()方法在列表中查找值"></a>4.3.1 用index()方法在列表中查找值</h3><pre><code>cat = [&apos;fat&apos;, &apos;black&apos;, &apos;loud&apos;]print(cat.index(&apos;black&apos;))1</code></pre><h3 id="4-3-2-用append-和insert-方法在列表中添加值"><a href="#4-3-2-用append-和insert-方法在列表中添加值" class="headerlink" title="4.3.2 用append()和insert()方法在列表中添加值"></a>4.3.2 用append()和insert()方法在列表中添加值</h3><p>append()方法调用，将参数  添加到列表末尾。insert()方法可以在列表任意下标处插入一个值。</p><p>insert()方法的第一个参数是新值的下标  ，第二个参数是要插入的新值。</p><h3 id="4-3-3-用remove-方法从列表中删除值"><a href="#4-3-3-用remove-方法从列表中删除值" class="headerlink" title="4.3.3 用remove()方法从列表中删除值"></a>4.3.3 用remove()方法从列表中删除值</h3><p>给 remove()方法传入一个值，它将从被调用的列表中删除，如果该值在列表中出现多次，只有第一次出现的值会被删除。</p><h3 id="4-3-4-用sort-方法将列表中的值排序"><a href="#4-3-4-用sort-方法将列表中的值排序" class="headerlink" title="4.3.4 用sort()方法将列表中的值排序"></a>4.3.4 用sort()方法将列表中的值排序</h3><p>数值的 列表或字符串的列表，能用sort()方法排序；也可以指定reverse关键字参数为True，让sort()按<strong>逆序排序</strong>。</p><p>sort()方法对字符串排序时，使用“ASCII字符顺序”， 而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时，小写的a在大写的Z之后。</p><pre><code>spam = [&apos;Alice&apos;, &apos;ants&apos;, &apos;Bob&apos;, &apos;badgers&apos;, &apos;Carol&apos;, &apos;cats&apos;]spam.sort()print(spam)[&apos;Alice&apos;, &apos;Bob&apos;, &apos;Carol&apos;, &apos;ants&apos;, &apos;badgers&apos;, &apos;cats&apos;]</code></pre><p>如果需要按照普通的字典顺序来排序，就在sort()方法调用时，将关键字参数key设置为str.lower。</p><pre><code>    spam = [&apos;a&apos;, &apos;z&apos;, &apos;A&apos;, &apos;Z&apos;]    spam.sort(key=str.lower)    spam[&apos;a&apos;, &apos;A&apos;, &apos;z&apos;, &apos;Z&apos;]</code></pre><h2 id="4-4-字符串和元组"><a href="#4-4-字符串和元组" class="headerlink" title="4.4 字符串和元组"></a>4.4 字符串和元组</h2><p>列表并不是唯一表示序列值的数据类型。</p><h3 id="4-4-1-不可变数据类型"><a href="#4-4-1-不可变数据类型" class="headerlink" title="4.4.1 不可变数据类型"></a>4.4.1 不可变数据类型</h3><p>“改变”一个字符串的正确方式，是使用切片和连接。构造一个“新的”字符串，从老的字符串那里复制一些部分。</p><pre><code>name = &apos;Zophie a cat&apos;newName = name[0:7] + &apos;the&apos; + name[8:12]print(newName)Zophie the cat</code></pre><h3 id="4-4-2-元组数据类型"><a href="#4-4-2-元组数据类型" class="headerlink" title="4.4.2 元组数据类型"></a>4.4.2 元组数据类型</h3><p>元组输入时用圆括号()，元组像字符串一样，是不可变的；如果元组中只有一个值，你可以在括号内该值的后面跟上一个逗号——逗号告诉Python，这是一个元组。</p><h3 id="4-4-3-用list-和tuple-函数来转换类型"><a href="#4-4-3-用list-和tuple-函数来转换类型" class="headerlink" title="4.4.3 用list()和tuple()函数来转换类型"></a>4.4.3 用list()和tuple()函数来转换类型</h3><pre><code>print(tuple([&apos;cat&apos;, &apos;dog&apos;, 5]))print(list((&apos;cat&apos;, &apos;dog&apos;, 5)))  (&apos;cat&apos;, &apos;dog&apos;, 5)[&apos;cat&apos;, &apos;dog&apos;, 5]</code></pre><h3 id="4-4-4-引用"><a href="#4-4-4-引用" class="headerlink" title="4.4.4 引用"></a>4.4.4 引用</h3><pre><code>spam = [0, 1, 2, 3, 4, 5]cheese = spam cheese[1] = &apos;Hello!&apos;print(spam)print(cheese)[0, &apos;Hello!&apos;, 2, 3, 4, 5][0, &apos;Hello!&apos;, 2, 3, 4, 5]</code></pre><h3 id="4-4-5-copy模块的copy-和deepcopy-函数"><a href="#4-4-5-copy模块的copy-和deepcopy-函数" class="headerlink" title="4.4.5  copy模块的copy()和deepcopy()函数"></a>4.4.5  copy模块的copy()和deepcopy()函数</h3><p>copy.copy()，可以用来复制列表或字典这样的可变值，而不只是复制引用。</p><pre><code>import copyspam = [&apos;Alice&apos;, &apos;ants&apos;, &apos;Bob&apos;, &apos;badgers&apos;]cheese = copy.copy(spam)cheese[1] = &apos;wo&apos;print(cheese)print(spam)[&apos;Alice&apos;, &apos;wo&apos;, &apos;Bob&apos;, &apos;badgers&apos;][&apos;Alice&apos;, &apos;ants&apos;, &apos;Bob&apos;, &apos;badgers&apos;]</code></pre><p>deepcopy()函数将同时复制它们内部的列表，即用copy.deepcopy()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;h2 id=&quot;4-1-列表数据类型&quot;&gt;&lt;a href=&quot;#4-1-列表数据类型&quot; class=&quot;headerlink&quot; title=&quot;4.1 列
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/27/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/27/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-27T01:23:49.901Z</published>
    <updated>2020-02-27T02:53:02.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h1><h2 id="3-1-def语句和参数"><a href="#3-1-def语句和参数" class="headerlink" title="3.1 def语句和参数"></a>3.1 def语句和参数</h2><pre><code>def hello(name):#1    print(&apos;Hello&apos; + name)hello(&apos; Alice&apos;)hello(&apos; Bob&apos;)</code></pre><p>自定义函数 hello(),’name’为变量，当hello()函数被调用时，参数就存放在其中。</p><p>如果你在 hello(‘Bob’) 之后添加 print(name)，程序会报 NameError，因为没有名为 name 的变量。在函数调用 hello(‘Bob’) 返回后，这个变量被销毁了，所以print(name) 会引用一个不存在的变量 name。</p><h2 id="3-2-返回值和-return语句"><a href="#3-2-返回值和-return语句" class="headerlink" title="3.2 返回值和 return语句"></a>3.2 返回值和 return语句</h2><ol><li>用def语句创建函数时，可以用 return 语句指定应该返回什么值。return 语句包含以下部分：return 关键字；函数应该返回的值或表达式。</li></ol><pre><code>import randomdef getAnswer(answerNumber):    if answerNumber == 1:        return &apos;It is certain&apos;    elif answerNumber == 2:        return &apos;It is decidedly so&apos;    elif answerNumber == 3:        return &apos;Yes&apos;    elif answerNumber == 4:        return &apos;Reply hazy try again&apos;    elif answerNumber == 5:        return &apos;Ask again later&apos;    elif answerNumber == 6:        return &apos;Concentrate and ask again&apos;    elif answerNumber == 7:        return &apos;My reply is no&apos;    elif answerNumber == 8:        return &apos;Outlook not so good&apos;    elif answerNumber == 9:        return &apos;Very doubtful&apos;r = random.randint(1, 9)fortune = getAnswer(r)print(fortune)#print(getAnswer(random.randint(1,9)))</code></pre><p>(图)</p><p>注释：定义getAnswer()函数，但不被调用，执行会跳过其中代码。接着random.randint()函数被调用，带两个参数 1和9 ，并且生成的一个随机整数值被存在一个名为r的变量中。</p><p>然后getAnswer()函数被调用，以r作为参数。r的值被保存到名为answerNumber的变元中。根据answerNumber中的值，函数返回许多可能字符串中的一个。程序执行返回到程序底部的代码行，即原来调用getAnswer()的地方。返回的字符串被赋给一个名为fortune变量，然后它又被传递给print()调用，并被打印在屏幕上。</p><h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h2><p>在Python中有一个值称为None，它表示没有值。None是NoneType数据类型的唯一值。</p><h2 id="3-4-关键字参数和-print"><a href="#3-4-关键字参数和-print" class="headerlink" title="3.4 关键字参数和 print()"></a>3.4 关键字参数和 print()</h2><ol><li><p>print()函数有可选的   变元end和sep，分别指定在参数末尾打印什么，以及在   参数之间打印什么来隔开它们。</p><pre><code>print(&apos;Hello&apos;, end=&apos;&apos;)print(&apos;World&apos;)HelloWorld</code></pre></li></ol><p>注释：end关键字参数，将它变成另一个字符串；sep关键字参数，替换掉默认的分隔字符串。</p><h2 id="3-5-局部和全局作用域"><a href="#3-5-局部和全局作用域" class="headerlink" title="3.5 局部和全局作用域"></a>3.5 局部和全局作用域</h2><ol><li><p>只有全局变量能用于全局作用域</p></li><li><p>局部作用域不能使用其他局部作用域内的变量，即一个函数中的局部变量完全与其他函数中的局部变量分隔开来。</p></li><li><p>全局变量可以在局部作用域中读取</p></li><li><p>名称相同的局部变量和全局变量</p></li></ol><h2 id="3-6-global语句"><a href="#3-6-global语句" class="headerlink" title="3.6 global语句"></a>3.6 global语句</h2><p>如果需要在一个函数内修改全局变量，就使用global语句。</p><p>有4条法则 ，来区分一个变量是处于局部作用域还是全局作用域：</p><p>1．如果变量在全局作用域  中使用（   即在所有函数之外），它就总是全局变量。</p><p>2．如果在一个函数中，有针对该变量的global语句，它就是全局变量。</p><p>3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。</p><p>4．但是，如果该变量没有用在赋值语句中，它就是全局变量。</p><pre><code>def spam():  global eggs   eggs = &apos;spam&apos;# this is the global   def bacon():      eggs = &apos;bacon&apos; # this is a local   def ham():       print(eggs) # this is the global    eggs = 42 # this is the global  spam()   print(eggs）</code></pre><p>（图）</p><h2 id="3-7-异常处理"><a href="#3-7-异常处理" class="headerlink" title="3.7 异常处理"></a>3.7 异常处理</h2><p>错误可以由try和except语句来处理。那些可能出错的语句被放在try子句中。如果错误发生，程序执行就转到接下来的except子句开始处。</p><pre><code>def spam(divideBy):    try:         return 42 / divideBy    except ZeroDivisionError:        print(&apos;Error: Invalid argument.&apos;)         print(spam(2))        print(spam(12))        print(spam(0))        print(spam(1)</code></pre><p>（图）</p><h2 id="3-8-小程序：猜数字"><a href="#3-8-小程序：猜数字" class="headerlink" title="3.8 小程序：猜数字"></a>3.8 小程序：猜数字</h2><pre><code># This is a guess the number game.import randomsecretNumber = random.randint(1, 20)print(&apos;I am thinking of a number between 1 and 20.&apos;)# Ask the player to guess 6 times.for guessesTaken in range(1, 7):    print(&apos;Take a guess.&apos;)    guess = int(input())    if guess &lt; secretNumber:        print(&apos;Your guess is too low.&apos;)    elif guess &gt; secretNumber:        print(&apos;Your guess is too high.&apos;)    else:        break # This condition is the correct guess!if guess == secretNumber:    print(&apos;Good job! You guessed my number in &apos; + str(guessesTaken) + &apos; guesses!&apos;)else:    print(&apos;Nope. The number I was thinking of was &apos; + str(secretNumber))</code></pre><p>（图）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-函数&quot;&gt;&lt;a href=&quot;#第三章-函数&quot; class=&quot;headerlink&quot; title=&quot;第三章 函数&quot;&gt;&lt;/a&gt;第三章 函数&lt;/h1&gt;&lt;h2 id=&quot;3-1-def语句和参数&quot;&gt;&lt;a href=&quot;#3-1-def语句和参数&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-26T14:21:14.304Z</published>
    <updated>2020-02-26T15:44:54.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-控制流"><a href="#第二章-控制流" class="headerlink" title="第二章 控制流"></a>第二章 控制流</h1><h2 id="2-1-布尔值"><a href="#2-1-布尔值" class="headerlink" title="2.1 布尔值"></a>2.1 布尔值</h2><p>Boolean（布尔）的首字母大写，“布尔”数据类型只有两种值：True和False。</p><pre><code>&gt;&gt;&gt;spam=True&gt;&gt;&gt;spamTrue</code></pre><h2 id="2-2-比较操作符"><a href="#2-2-比较操作符" class="headerlink" title="2.2 比较操作符"></a>2.2 比较操作符</h2><p>（图）</p><p>ps：整型或浮点型的值永远不会与字符串相等。<br>   &lt;、&gt;、&lt;=和&gt;=操作符仅用于整型和浮点型。</p><h2 id="2-3-布尔操作符"><a href="#2-3-布尔操作符" class="headerlink" title="2.3 布尔操作符"></a>2.3 布尔操作符</h2><p>3个布尔操作符（and、or和not）用于比较布尔值</p><p>（图）</p><p>只要有一个布尔值为真，or操作符就将表达式求值为True。如果都是False，所求值为False。</p><p>not操作符只作用于一个布尔值（或表达式  ）。not操作符  求值为相反的布尔值。</p><h2 id="2-4-混合布尔和比较操作符"><a href="#2-4-混合布尔和比较操作符" class="headerlink" title="2.4 混合布尔和比较操作符"></a>2.4 混合布尔和比较操作符</h2><p>计算机将先求值左边的表达式，然后再求值右边的表达式。知道两个布尔值后，它又将整个表达式再求值为一个布尔值。</p><pre><code>&gt;&gt;&gt;(4 &lt; 5) and (5 &lt; 6)True</code></pre><p>和算术操作符一样，布尔操作符也有操作顺序。在所有算术和比较操作符求值后，Python先求值not操作符， 然后是and操作符 ，然后是or操作符。</p><pre><code>&gt;&gt;&gt; 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2True </code></pre><h2 id="2-5-控制流的元素"><a href="#2-5-控制流的元素" class="headerlink" title="2.5 控制流的元素"></a>2.5 控制流的元素</h2><h3 id="2-5-1-if-语句"><a href="#2-5-1-if-语句" class="headerlink" title="2.5.1 if 语句"></a>2.5.1 if 语句</h3><pre><code>if name == &apos;Alice&apos;:    print(&apos;Hi, Alice.&apos;)</code></pre><h3 id="2-5-2-while循环"><a href="#2-5-2-while循环" class="headerlink" title="2.5.2 while循环"></a>2.5.2 while循环</h3><pre><code> spam = 0 while spam &lt; 5:     print(&apos;Hello, world.&apos;)     spam = spam + 1 Hello, world*5name = &apos;&apos;while name != &apos;your name&apos;:    print(&apos;输入你的名字：&apos;)    name = input()print(&apos;谢谢。&apos;)</code></pre><p>（图）</p><h3 id="2-5-3-break-语句"><a href="#2-5-3-break-语句" class="headerlink" title="2.5.3 break 语句"></a>2.5.3 break 语句</h3><pre><code>while True:    print(&apos;输入你的名字：&apos;)    name = input()    if name == &apos;your name&apos;:        breakprint(&apos;谢谢。&apos;)</code></pre><p>（图）</p><h3 id="2-5-4-continue-语句"><a href="#2-5-4-continue-语句" class="headerlink" title="2.5.4 continue 语句"></a>2.5.4 continue 语句</h3><p>像break语句一样，continue语句用于循环内部。如果程序执行遇到continue语句，就会马上跳回到循环开始处，重新对循环条件求值（这也是执行到达循环末尾时发生的事情）。</p><pre><code>while True:    print(&apos;Who are you?&apos;)    name = input()    if name != &apos;c&apos;:        continue    print(&apos;Hello, Joe. What is the password? (It is a fish.)&apos;)    password = input()   if password == &apos;swordfish&apos;:       breakprint(&apos;Access granted.&apos;)</code></pre><p>（图）</p><h3 id="2-5-5-for循环和-range-函数"><a href="#2-5-5-for循环和-range-函数" class="headerlink" title="2.5.5 for循环和 range()函数"></a>2.5.5 for循环和 range()函数</h3><pre><code>for i in range(5):</code></pre><p>for关键字；一个变量名；in关键字；调用range()方法，最多传入3个参数；冒号；从下一行开始，缩退的代码块（称为for子句）。</p><pre><code>print(&apos;My name is&apos;) for i in range(5):    print(&apos;Jimmy Five Times (&apos; + str(i) + &apos;)&apos;)total = 0for num in range(101):    total = total + numprint(total)5050</code></pre><h3 id="2-5-6-等价的-while-循环"><a href="#2-5-6-等价的-while-循环" class="headerlink" title="2.5.6 等价的 while 循环"></a>2.5.6 等价的 while 循环</h3><pre><code>print(&apos;My name is&apos;)i = 0while i &lt; 5:    print(&apos;Jimmy Five Times (&apos; + str(i) + &apos;)&apos;)    i = i + 1</code></pre><p>(图)</p><h3 id="2-5-7-range-的开始、停止和步长参数"><a href="#2-5-7-range-的开始、停止和步长参数" class="headerlink" title="2.5.7 range()的开始、停止和步长参数"></a>2.5.7 range()的开始、停止和步长参数</h3><pre><code>for i in range(12, 16):    print(i)for i in range(0,10,2):    print(i)for i in range(5,-1,-1):    print(i)</code></pre><h2 id="2-6-sys-exit-提前结束程序"><a href="#2-6-sys-exit-提前结束程序" class="headerlink" title="2.6 sys.exit()提前结束程序"></a>2.6 sys.exit()提前结束程序</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章-控制流&quot;&gt;&lt;a href=&quot;#第二章-控制流&quot; class=&quot;headerlink&quot; title=&quot;第二章 控制流&quot;&gt;&lt;/a&gt;第二章 控制流&lt;/h1&gt;&lt;h2 id=&quot;2-1-布尔值&quot;&gt;&lt;a href=&quot;#2-1-布尔值&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/26/python%E5%A4%8D%E4%B9%A01/"/>
    <id>http://yoursite.com/2020/02/26/python%E5%A4%8D%E4%B9%A01/</id>
    <published>2020-02-26T10:05:01.813Z</published>
    <updated>2020-02-26T14:20:52.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="1-1-表达式"><a href="#1-1-表达式" class="headerlink" title="1.1 表达式"></a>1.1 表达式</h2><p>表达式包含“值”和“操作符”， 并且总是可以求值（也就是归约）为单个值。<br>交互式环境下：</p><p><code>&gt;&gt;&gt; 2 + 2</code></p><p>  <code>4</code></p><p>（图）</p><p>数学操作符的操作顺序（也称为“优先级”）与数学中类似。</p><p>操作符的优先顺序为：*<em>、</em>、/、//和%，从左到右。+和-最后求值，也是从左到右。</p><p>##1.2  整型、浮点型和字符串数据类型 ##</p><p>表1-2常见数据类型数据类型（图）</p><h2 id="1-3-字符串连接和复制"><a href="#1-3-字符串连接和复制" class="headerlink" title="1.3 字符串连接和复制"></a>1.3 字符串连接和复制</h2><p>‘+’用于字符串连接；’*’用于字符串复制。</p><p>在用于<strong>两个整型</strong>或浮点型值时，’<em>‘操作符表示乘法。但’</em>‘操作符用于一个字符串值和一个整型值时，它变成了“字符串复制”操作符。</p><h2 id="1-3-赋值语句"><a href="#1-3-赋值语句" class="headerlink" title="1.3 赋值语句"></a>1.3 赋值语句</h2><h3 id="1-3-1-变量名"><a href="#1-3-1-变量名" class="headerlink" title="1.3.1 变量名"></a>1.3.1 变量名</h3><p>遵守以下3条规则 ：</p><p>1．只能是一个词。</p><p>2．只能包含字母、数字和下划线。</p><p>3．不能以数字开头。</p><p>（且变量名区分大小）</p><h2 id="1-4-print-函数"><a href="#1-4-print-函数" class="headerlink" title="1.4  print()函数"></a>1.4  print()函数</h2><pre><code>print(&apos;Hello world!&apos;)print(&apos;What is your name?&apos;) # ask for their nam</code></pre><p>##1.5 input()函数 ##</p><p>函数等待用户在键盘上输入一些文本，并按下回车键(input()函数总是返回一个字符串):</p><pre><code>myName = input(）print(&apos;It is good to meet you, &apos; + myName）</code></pre><h2 id="1-6-len-函数"><a href="#1-6-len-函数" class="headerlink" title="1.6 len()函数"></a>1.6 len()函数</h2><p>可以向len()函数传递一个字符串（或包含字符串的变量），然后该函数求值为一个整型值，即字符串中字符的个数。</p><pre><code>len(&apos;hello&apos;)5len(&apos;My very energetic monster just scarfed nachos.&apos;)46 len(&apos;&apos;)0</code></pre><p>len(myName)求值为一个整数。</p><h2 id="1-7-str-、int-和float-函数"><a href="#1-7-str-、int-和float-函数" class="headerlink" title="1.7 str()、int()和float()函数"></a>1.7 str()、int()和float()函数</h2><p>str()函数可以传入一个整型值，并求值为它的字符串形式:</p><pre><code>str(29)&apos;29&apos; print(&apos;I am &apos; + str(29) + &apos; years old.&apos;)I am 29 years old.</code></pre><p>str()、int()和float()函数将分别求值为传入 值的字符串、整数和浮点数形式。</p><pre><code>str(0)&apos;0&apos; &gt;&gt;&gt; str(-3.14)&apos;- 3.14&apos;int(&apos;42&apos;)42  int(&apos;-99&apos;)  -99 int(1.25)1 int(1.99)1  float(&apos;3.14&apos;)3.14float(10)10.0</code></pre><p>对浮点数进行取整运算，也可以用int()函数。</p><pre><code>int(7.7)7 int(7.7) + 18</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python基础&quot;&gt;&lt;a href=&quot;#Python基础&quot; class=&quot;headerlink&quot; title=&quot;Python基础&quot;&gt;&lt;/a&gt;Python基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-表达式&quot;&gt;&lt;a href=&quot;#1-1-表达式&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/10/16/%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/16/%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2019-10-16T12:53:20.854Z</published>
    <updated>2019-10-16T12:53:21.351Z</updated>
    
    <content type="html"><![CDATA[<pre><code> import requests from multiprocessing import pool from requests.exceptions import RequestException import re import jsondef get_one_page(url):#请求单页的url#引用requests要进行异常处理，用RequestException    try:        response = requests.get(url, headers=headers)    #通过状态码进行判断，是否成功        if response.status_code == 200:            return response.text        return None    except RequestException:        return None</code></pre><p>#定义一个main函数<br>    def main():</p><pre><code>url = &apos;http://maoyan.com/board/4?offset=&apos; + str(offset)html = get_one_page(url)print(html)#判断，并调用main方法 if __name__ == &apos;__main__&apos;:         main(i*10)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt; import requests
 from multiprocessing import pool
 from requests.exceptions import RequestException
 import re
 import json
def 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/28/%E5%81%87%E6%9C%9F%E6%84%9F%E6%82%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/08/28/%E5%81%87%E6%9C%9F%E6%84%9F%E6%82%9F%E6%80%BB%E7%BB%93/</id>
    <published>2019-08-28T05:28:19.555Z</published>
    <updated>2019-08-28T05:28:19.698Z</updated>
    
    <content type="html"><![CDATA[<p>当这篇文章发出来的时候，我应该已经在火车上了，再一次踏上去求学的路上。我能想象自己坐在火车上看车窗外风景一闪一闪而过的场景。</p><p>上学意味着一个暑假结束了，也意味着属于自己的自由日子又少了。如果毕业就工作，那么算下来你的大学也就只有五个寒暑假是属于自己的，以后基本没有属于自己的假期。</p><p>大二的这个暑假我不敢说自己进步了，用以前班主任说的一句话来讲：“学如逆水行舟，小进则退”。如果只感觉到自己有一点点进步，那真的算不上什么，别人可能稍微一努力就把你一个暑假的成果给超越了。</p><p>想起大一暑假我和朋友商量着搞一个公众号，咱们也写文章，也想象能写出一个10万+的文章。这样我们就能够火起来了，我们也是有流量的人了。</p><p>然后忙忙碌碌也没写出个什么名堂，我们意识到自己真的是阅读太少、积累太少、经验太少，一时间成功不了的。</p><p>到这个暑假，我们再次回到写作的状态。那些写作牛逼的人不是说：“最起码写够10万字的输入才能算是入门写作”吗？我们就先写它个10万字，在不断的写作过程中，总会不断进步，找到属于自己的风格和节奏。</p><p>和朋友相处的一件事</p><p>我经常和董帅（昵称）在微信上聊着聊着就吵起来，有时候就是因为一句话它背后的情感。他（我）没有加上标点符号或者一个表情，然后对方就会根据当前自己理解的语境揣度起这句话的意思。往往一句好意的话，到对方那里就变成了不爽的意思。</p><p>我倒不是说朋友之间的关系不怎么样，只要你不是和他一直生活在一起，这样的问题总会发生。我也是因为这样的事，明白了表情包的用处，它不仅可以调动当前聊天的氛围，也能够让对方明白当前聊天的语境。其实发语音也能比较好的解决这个问题，但有时候对方不方便听也是一个问题。</p><p>所以我的意思是，大家以后和别人用打字的方式和别人聊天的时候，尽量加上标点符号或者表情和表情包这类辅助工具。不仅能够大大的提高聊天的效率，也能避免不必要的争吵。</p><p>关于打篮球</p><p>我觉得真正喜欢打篮球的孩子会有一个共同的特点——有脾气。在场上，他们会尽自己的全力去赢得比赛。即便和对手发生摩擦都是为了想要赢球，我们会口吐芬芳，甚至说出一句：“你打球像蔡徐坤”。这样让敌军战斗力瞬间减少1000的大杀招。（不谈那些小人，喜欢伤害别人的人）</p><p>生活中，我们也是有脾气的，像我可能就属于古怪的那一类，我给自己这样的定位。</p><p>怀念高中</p><p>上个星期写文章一时没找到素材，遂上B站放松一下。看到关注的up主解说《小欢喜》的视频，就点进去看了看。<br>看完后，我真的有陷入到当年那时候自己生活的状态的回忆中去。然后前两天和一群自己刚高中毕业的发小一起吃饭，听他们说说自己高三的故事。晚上回到家，又想到小欢喜里面的故事后，我感伤了起来。</p><p>我以前总在心里告诉自己高三已经过去了，你也逃离了那个残酷的环境，现在就看前方好啦。可那一刻，我好想再回到高中。也许是有太多的遗憾，不论是对学业，还是对那时候喜欢的姑娘。</p><p>也许是我更想逃离现在的自己，看着自己越来越大，趋向于成熟，反而还是愿意当父母的乖宝宝。做错事了，父母可以帮我们承担大部分的责任，自己还可以照旧没心没肺的。我，怀念高中！</p><p>健身的事儿</p><p>暑假去了健身房，最大的愿望是可以练出腹肌，达成好久之前立下的flag。可暑假见底，我肚子上的小赘肉还是舍不得我。这事估计急不来，我就慢慢调整自己的饮食，争取保证身体健康的状况下，减掉肚子上的脂肪。不过，胳膊练的还不错，应该是长肌肉了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当这篇文章发出来的时候，我应该已经在火车上了，再一次踏上去求学的路上。我能想象自己坐在火车上看车窗外风景一闪一闪而过的场景。&lt;/p&gt;
&lt;p&gt;上学意味着一个暑假结束了，也意味着属于自己的自由日子又少了。如果毕业就工作，那么算下来你的大学也就只有五个寒暑假是属于自己的，以后基本
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/26/%E6%99%AE%E9%80%9A%E9%98%B6%E5%B1%82%E9%9D%A0%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E8%84%89%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/08/26/%E6%99%AE%E9%80%9A%E9%98%B6%E5%B1%82%E9%9D%A0%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA%E8%84%89%EF%BC%9F/</id>
    <published>2019-08-26T07:04:53.118Z</published>
    <updated>2019-08-26T07:04:53.229Z</updated>
    
    <content type="html"><![CDATA[<p>普通阶层的人靠什么样的人脉？</p><p>还记得前年特别火的《人民的名义》吗？里面的祁同伟，一个信仰自己能够“胜天半子”的男人。为什么他一个出身农民家庭的孩子能够当上了公安厅长呢？他曾今想靠着自己的努力一步步走上去，可现实却沉重的打击了他，让他走上不归路。</p><p>我相信很多人不喜欢剧中他的人设，为了达到自己的目的，改变自己的命运，在众目之下向比自己大十岁的梁璐老师跪地求婚。我当初看的时候也不喜欢他这种人，但内心里又多少同情他。而正是这一跪，他的人生轨迹彻底改变了。那个意气风发的祁同伟不复存在，他变成了臣服于权利的两面派。同时他当初想要的权利和地位也都得到了。</p><p>其实当故事发生到这里还算好的，可恨的是在今后的仕途中，他可谓是不择手段，连杀人他都可以不眨眼睛。我们可以理解他下跪，更可以同情他，至少他只是为了前途的一个小人。</p><p>最后在他所谋划的事情败露后他说到：“我们处在一个千载难逢的机会，能够通过努力改变自身的命运，甚至改变整个家族的命运。这种机会以后再也不会有了，如果我们这代人不为此付出代价，那么我们的下一代就要重蹈覆辙。为了抓住这个机会改变命运，我可以不择一切手段”。由此，他便不再让人同情，就连当初下跪也是变得龌龊可耻。</p><p>如果我们再试着跳出剧情，其实他不过是不甘于平庸，在挑战人生的道路上迷失了方向，扭曲了理想，在光明与黑暗的博弈中毁灭了自我的可怜人。</p><p>像他这样虽然是农民出身，他至少大学同学和老师的背景都是听厉害的。而反观像我们这样一群结识的人缘背景都不大，出身最多富贵的人，靠什么样的人脉？</p><p>在我家这样一个小城镇上，我经常能听到一些故事，关于大家怎么混的。让我记忆比较深的是刚毕业的一个高中生，他已经在社会上建立起了自己的一套人脉系统。从他的口中，我听到了几点：1、现在还年轻，要出去闯，走到哪至少不会饿死。2、出门在外要结交各方面的人，打好关系，至少以后外面有难，有人会帮你。3、多认识一些有钱的人，比如土豪。总有一些没脑子的，他们会非常乐意和你玩。</p><p>了解到这些后，我还是挺吃惊的，一个小镇上的孩子，还没怎么经历过社会的磨练而且还在那么大的学习压力下，能懂得这些是很有悟性。但我还是挺难受的，可以以他的这种想法、做法，可能真的能生活的不错，可意义到底在哪里呢？</p><p>我也经常听到身边的朋友靠着谁谁谁得到了什么好东西，或者提前给他找好了工作岗位，拿着高工资，还不累。然后我就问自己，羡慕吗？当然羡慕，我还嫉妒。但我总能够转念一想，别人是别人，自己是自己，只要我自己能够做喜欢的事，开开心心就行。</p><p>最后，平民阶层的我们其实还是非常需要人脉，有时候我们辛辛苦苦的努力却得不到回报，但你认识的人可能只需一句话就能够让你通过能力实现抱负。人脉固然重要，但我们也需要认清楚自己和甄别人脉关系。大家需要相信，这个时代并不缺少伯乐，只要你有能力，机遇大把抓，你生而逢时。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;普通阶层的人靠什么样的人脉？&lt;/p&gt;
&lt;p&gt;还记得前年特别火的《人民的名义》吗？里面的祁同伟，一个信仰自己能够“胜天半子”的男人。为什么他一个出身农民家庭的孩子能够当上了公安厅长呢？他曾今想靠着自己的努力一步步走上去，可现实却沉重的打击了他，让他走上不归路。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/24/%E3%80%8A%E5%B0%8F%E6%AC%A2%E5%96%9C%E3%80%8B%E7%9C%9F%E7%9A%84%E6%AC%A2%E5%96%9C%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/08/24/%E3%80%8A%E5%B0%8F%E6%AC%A2%E5%96%9C%E3%80%8B%E7%9C%9F%E7%9A%84%E6%AC%A2%E5%96%9C%E5%90%97%EF%BC%9F/</id>
    <published>2019-08-24T02:20:58.616Z</published>
    <updated>2019-08-24T02:21:13.811Z</updated>
    
    <content type="html"><![CDATA[<p>《小欢喜》真的欢喜吗？</p><p>大家应该有听过最近比较火的电视剧《小欢喜》吧，一个永远都是热点的话题——教育。为什么这部剧能够让观众们不去挑剔呢？就连我看了关于这部剧的解说后，都觉得不错。</p><p>我想最重要的原因是因为它的真实性。相比较之前扑街的《带着爸爸去留学》而言，去掉虚假的外壳和不切实际的胡编乱造，《小欢喜》让我们这群经历过高三洗礼过的孩子，得到了认同感。</p><p>相信大家认同高三是一场战争，这场战争其实从高二下学期后半段就开始了。基本上各个学校的老师都会告诉学生，怎么来度过高三，怎么面对待最后一场考试。记得我高三那年，学校分了“实验班”和“平行班”，实验班意味着更好的老师和更爱学习的同学，等于学校对你寄予了厚望。不管在哪样的班级，还都必须得好好备战。</p><p>警钟敲响，紧接着就是不停的训练：周考、月考、模拟考。</p><p>而在剧中，我似乎看到了和我相似的经历，相似但不相同。那就是方圆和童文洁的家庭。</p><p>他们家境中产收入稳定，方圆是慈父，父子两都随性。他家重视人格的培养，不过分注重孩子成绩。童文洁是严母，但不苛刻，为孩子的成绩操碎了心，但不过多干涉他。儿子方一凡成绩太差，但大气随和，知道关心人，是个不遭人嫌弃的主。他们家为了让孩子上学近，连一个月一万块房租费的学区房也租下了。</p><p>而当时我的家庭也算是收入稳定，爸妈也都理解我、支持我。为了让我高三一年有个好的学习环境和生活环境，也租了学校对面的学区房，让我妈来专心带我。而我爸自己一个人挣钱，时不时就打电话问问我情况，也不过分要求我要怎样。</p><p>似乎他们也在无形的告诉我，我们想要你能够快乐的，然后认真学习，自己的人生需要自己去把握。他们没有什么文化和成就也没有说把自己的抱负强压在我身上。他们只是用他们的爱，让我一步一步向远方走去。</p><p>当我状态不好，对未来迷茫又恐慌的时候，我爸第一时间到租房那里和我谈心。让我一定不要有压力，还没有到最后一刻，更不要选择放弃。我懦弱的哭泣时，他更没有凶我，只能暗自和我一起哭。正是因为这样，高三那一年的战役，我才能勇敢的走到最后。</p><p>是啊，现在想想那时候真的还是比较脆弱的，因为自己平时状态很好，一到考试就废了。心里的压力确实大，加上身体上有些不适。对自己，自信又自卑，知道自己脑子不差，但有些题就是死活做不对。</p><p>时常会孤独、急躁，觉得没有人懂自己，周围人都只看成绩，却不问问你心里究竟怎么想。</p><p>我想应该会有很多人跟我一样有这些感受。我们是经历过高考的人，所以会对这部剧产生亲切感。其实也是因为我再剧里看到了曾经的自己和父母。让我为自己能有这样的父母感到骄傲。</p><p>《小欢喜》用高考的切入点也反映出了最真实的问题：父母不理解孩子，孩子也很难理解父母。每个人都在自说自话，强调自己的付出。即便平时是能看到的对方的付出，但在压力疲倦的时候，都只顾着发泄自己的情绪。</p><p>每个人高三的故事都不相同，但我想我们这些直面高考的孩子，都是幸运的，结局都是欢喜的。因为我们是“胜利者”。所以《小欢喜》真的欢喜，是因为他们最后都解决了高三一年中家里遇到的问题，像是父子间、母女间的隔阂。我也希望每个经历过或者将要经历高考的孩子，都能够欢喜的过着自己想要的生活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《小欢喜》真的欢喜吗？&lt;/p&gt;
&lt;p&gt;大家应该有听过最近比较火的电视剧《小欢喜》吧，一个永远都是热点的话题——教育。为什么这部剧能够让观众们不去挑剔呢？就连我看了关于这部剧的解说后，都觉得不错。&lt;/p&gt;
&lt;p&gt;我想最重要的原因是因为它的真实性。相比较之前扑街的《带着爸爸去留
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/20/%E5%85%B4%E8%B5%B7%E7%9A%84%E2%80%9C%E6%98%8E%E5%AD%A6%E2%80%9D%E5%86%8D%E4%B8%8D%E5%AD%A6%E5%B0%B1%E6%99%9A%E5%95%A6/"/>
    <id>http://yoursite.com/2019/08/20/%E5%85%B4%E8%B5%B7%E7%9A%84%E2%80%9C%E6%98%8E%E5%AD%A6%E2%80%9D%E5%86%8D%E4%B8%8D%E5%AD%A6%E5%B0%B1%E6%99%9A%E5%95%A6/</id>
    <published>2019-08-20T14:43:46.513Z</published>
    <updated>2019-08-20T14:43:46.640Z</updated>
    
    <content type="html"><![CDATA[<p>兴起的“明学”你开始学习了吗？</p><p>不知道大家最近有没有听说“明学”，简而言之就是著名影星黄晓明所创建的一门学问。</p><p>我们且来看看“明学”的由来。</p><p>有一档子综艺节目叫《中餐厅》，刚开始第一、二季时有赵薇压阵，明哥的“明学”还只是他一个人在专研创作。等到第三季他一跃成为主角时便大力推行“明学”。可以说是，“明学”诞生的幕后工程是赵薇，没有她参与《中餐厅》的录制，才能让“明学”得以传播，让更多的人可以了解，可以去学习这门兴起的学科。</p><p>由此，我们来分析一下“明学”有哪些分类：</p><p>第一类：霸道总裁范，献媚老外，刚愎自用式都听我的。</p><p>第二类：宽容对外范，博取好感，严格对内玩双标。</p><p>第三类：避重就轻范，嘴炮压制，解决不了就会口头道歉。</p><p>第四类：舆论洗白范，重新剪辑，重新配音微博洗白。</p><p>了解完这些个分类大家肯定还会一脸疑惑，毕竟这么深奥的“明学”不是我们这些凡夫俗子能轻易就学会明白的。其实，所谓“明学”也和其他六书一样，有很多朗朗上口的金典语录。这些“明言明句”真的是让人一下子就记住并印在脑海里。</p><p>下面就是“明学”十大金句：</p><p>1、我不要你觉得，我要我觉得</p><p>2、你们不要闹了，就这样，都听我的</p><p>3、我不觉得是这个问题</p><p>4、这是你的问题，你必须要解决</p><p>5、这个问题不需要商量，都听我的</p><p>6、万一呢？要是有一个人想吃三分餐</p><p>7、要不我觉得你别干了吧</p><p>8、买！什么都可以买</p><p>9、我不管几个，我要全部搞定，我再说一遍。全部搞定，不要问我几个，全部，都听懂了吗？全部搞定</p><p>10、我不管，我说一个就一个。</p><p>看完十大金句，是不是觉得“明学”果然是一门“深奥的学问”？</p><p>那么“明学”的背后到底体现出了什么呢？据我了解到，明哥的演技其实也有，他也能演出像《无问东西》这样的片子。但后期路线大都是霸道总裁范，像是在戏里面出不来了，把演戏当做的真实的生活，以至于现在做事说话全都一副装B的模样。</p><p>现在很多演员，有的甚至不能说是演员的流量明星，仗着自己的粉丝多，出名，开始起了耍大牌。不管是拍戏也好，还是在生活中也好，都有些目中无人。现在“明学”在网上炒的如此火爆，甚至网民们找出了当面明哥的黑料出来。不知道接下来节目组如何洗白，明哥能否挺过去？</p><p>希望这些有身份的人都能够多一点自知之明，也希望明哥可以挺过去（狗头保命）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;兴起的“明学”你开始学习了吗？&lt;/p&gt;
&lt;p&gt;不知道大家最近有没有听说“明学”，简而言之就是著名影星黄晓明所创建的一门学问。&lt;/p&gt;
&lt;p&gt;我们且来看看“明学”的由来。&lt;/p&gt;
&lt;p&gt;有一档子综艺节目叫《中餐厅》，刚开始第一、二季时有赵薇压阵，明哥的“明学”还只是他一个人在
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E6%88%91%E6%8B%BF%E7%83%AD%E8%84%B8%E8%B4%B4%E4%BD%A0%E7%9A%84%E5%86%B7%E5%B1%81%E8%82%A1%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/08/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%BB%E6%98%AF%E6%88%91%E6%8B%BF%E7%83%AD%E8%84%B8%E8%B4%B4%E4%BD%A0%E7%9A%84%E5%86%B7%E5%B1%81%E8%82%A1%EF%BC%9F/</id>
    <published>2019-08-20T01:13:35.544Z</published>
    <updated>2019-08-20T01:13:35.684Z</updated>
    
    <content type="html"><![CDATA[<p>为什么总要拿我的热脸贴你的冷屁股？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么总要拿我的热脸贴你的冷屁股？&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/08/18/%E7%9B%B2%E7%82%B9/"/>
    <id>http://yoursite.com/2019/08/18/%E7%9B%B2%E7%82%B9/</id>
    <published>2019-08-18T00:55:01.175Z</published>
    <updated>2019-08-18T01:11:55.074Z</updated>
    
    <content type="html"><![CDATA[<p>盲点：你的大脑总会对一事物的某一方面存在盲点</p><p>当你看到如下图片，第一时间在你脑子里所反映的是什么？<br><img src="https://img3.doubanio.com/view/thing_review/l/public/2204485.jpg" alt></p><p>我的第一反应是两个面对面的脸，而当我定睛一看出现的是花瓶，这就是盲点。</p><p>所谓盲点，这完全取决于你看待事物的方式，不管你怎么看，总会存在一个方面是你忽视的。现在我已经知道了上面这张图片可以看出来是花瓶和两张脸。那么这样我再次看这张图片时是否就不存在盲点了呢？</p><p>显然并不是，因为我们的大脑有它在第一时间想要看到的东西，这个是你无法控制的。除非你话费很长时间来训练你的大脑，显然这是非常难的一件事。因此，在没有任何可以训练的情况下，我们总会本能的对事物的某一方面存在盲点。</p><p>正如电影里男主问女主：”那你现在看到我的时候，总会第一时间看到那个大家的我吗？”此前，男主角因为恶意大家致人伤残而入狱两月，并获得一年假释。期间，男主角努力改正自己，走向了正轨。</p><p>而电话那头的女主角久久不语，男主伤痛的挂断电话。</p><p>即便男主努力的想要重新生活，可他那次伤人的画面却一直刻在了女主的脑子里。我不否认电影中男主朋友的行为给男主带来了一些负面的影响，可曾今的女友却没相信过自己喜欢的人会认真的改变自己的行径。这也是男主伤痛的一个原因吧。</p><p>跳出电影，我们谈谈自己身边的事。盲点是每个人都存在的，我们学生时代何尝不认为学习差的就没有教养，学习好的就有教养，什么都能行？也许是所谓经验的刻板印象导致，但你的大脑总不喜欢去往好的方面想，这就是一个盲点。</p><p>电影《blindspotting》中有很多话题，但我选择片名作为主题是因为它和我们的生活更相关。我们是否也可以问自己这样一个问题：“当所谓的固有偏见、经验思维在潜意识里能干扰到你的判断时，你面前的人在你的眼里，你的大脑会反映出什么呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;盲点：你的大脑总会对一事物的某一方面存在盲点&lt;/p&gt;
&lt;p&gt;当你看到如下图片，第一时间在你脑子里所反映的是什么？&lt;br&gt;&lt;img src=&quot;https://img3.doubanio.com/view/thing_review/l/public/2204485.jpg&quot; a
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
